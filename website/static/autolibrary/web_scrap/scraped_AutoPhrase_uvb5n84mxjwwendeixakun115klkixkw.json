[{"link": "https://arxiv.org/pdf/2102.00556.pdf", "title": "Random walks and forbidden minors III: poly(d/{\\epsilon})-time partition oracles for minor-free graph classes", "authors": [{"firstName": "Akash", "middleNames": [], "lastName": "Kumar"}, {"firstName": "C.", "middleNames": [], "lastName": "Seshadhri"}, {"firstName": "Andrew", "middleNames": [], "lastName": "Stolman"}], "abstract": "Consider the family of bounded degree graphs in any minor-closed family (such as planar graphs). Let d be the degree bound and n be the number of vertices of such a graph. Graphs in these classes have hyperfinite decompositions, where, for a sufficiently small \u03b5 > 0, one removes \u03b5dn edges to get connected components of size independent of n. An important tool for sublinear algorithms and property testing for such classes is the partition oracle, introduced by the seminal work of Hassidim-Kelner-Nguyen-Onak (FOCS 2009). A partition oracle is a local procedure that gives consistent access to a hyperfinite decomposition, without any preprocessing. Given a query vertex v, the partition oracle outputs the component containing v in time independent of n. All the answers are consistent with a single hyperfinite decomposition. The partition oracle of Hassidim et al. runs in time d ) per query. They pose the open problem of whether poly(d\u03b5\u22121)-time partition oracles exist. Levi-Ron (ICALP 2013) give a refinement of the previous approach, to get a partition oracle that runs in time d \u22121)-per query. In this paper, we resolve this open problem and give poly(d\u03b5\u22121)-time partition oracles for bounded degree graphs in any minor-closed family. Unlike the previous line of work based on combinatorial methods, we employ techniques from spectral graph theory. We build on a recent spectral graph theoretical toolkit for minor-closed graph families, introduced by the authors to develop efficient property testers. A consequence of our result is a poly(d\u03b5\u22121)-query tester for any monotone and additive property of minor-closed families (such as bipartite planar graphs). Our result also gives poly(d\u03b5\u22121)-query algorithms for additive \u03b5n-approximations for problems such as maximum matching, minimum vertex cover, maximum independent set, and minimum dominating set for these graph families. Department of Computer Science, EPFL. akash.kumar@epfl.ch Department of Computer Science, University of California, Santa Cruz. sesh@ucsc.edu Department of Computer Science, University of California, Santa Cruz. astolman@ucsc.edu CS and AS acknowledge the support of NSF grants CCF-1740850, CCF-1813165, CCF-1909790, CCF-2023495, and ARO Award W911NF1910294.", "date": "2021-01-31"}, {"link": "https://pdfs.semanticscholar.org/9eb6/55dfdef281a6904b1967c63e286db61b7c26.pdf", "title": "Graph drawing : Symposium on Graph Drawing, GD '96, Berkeley, California, USA, September 18-20, 1996, proceedings", "authors": [{"firstName": "S.", "middleNames": [], "lastName": "North"}], "abstract": "Bipartite embeddings of trees in the plane.- Series-parallel planar ordered sets have pagenumber two.- On rectangle visibility graphs.- A graph drawing and translation service on the WWW.- Drawing 2-, 3- and 4-colorable graphs in O(n2) volume.- Optimizing area and aspect ratio in straight-line orthogonal tree drawings.- Drawing directed acyclic graphs: An experimental study.- Circular layout in the Graph Layout toolkit.- Multilevel visualization of clustered graphs.- Straight-line drawing algorithms for hierarchical graphs and clustered graphs.- Graph-Drawing contest report.- Two algorithms for three dimensional orthogonal graph drawing.- 2-Visibility drawings of planar graphs.- Upper bounds on the number of hidden nodes in Sugiyama's algorithm.- Integration of declarative approaches (System Demonstration).- GIOTTO3D: A system for visualizing hierarchical structures in 3D.- A new minimum cost flow algorithm with applications to graph drawing.- Constrained graph layout.- The graphlet system (system demonstration).- On the Edge Label Placement problem.- Intersection graphs of noncrossing arc-connected sets in the plane.- Wiring edge-disjoint layouts.- Proximity drawings of outerplanar graphs (extended abstract).- Automatic visualization of two-dimensional cellular complexes.- An alternative method to crossing minimization on hierarchical graphs.- A linear-time algorithm for four-partitioning four-connected planar graphs.- Graphs drawn with few crossings per edge.- A pairing technique for area-efficient orthogonal drawings (extended abstract).- Experimental and theoretical results in interactive orthogonal graph drawing.- An interactive system for drawing graphs.- Automatic graph clustering (system demonstration).- Qualitative visualization of processes: Attributed graph layout and focusing techniques."}, {"link": "https://doi.org/10.1007/978-3-319-73814-7_5", "title": "Parallelizing Single Source Shortest Path with OpenSHMEM", "authors": [{"firstName": "Ferrol", "middleNames": [], "lastName": "Aderholdt"}, {"firstName": "J.", "middleNames": ["A."], "lastName": "Graves"}, {"firstName": "Manjunath", "middleNames": ["Gorentla"], "lastName": "Venkata"}], "abstract": "Single Source Shortest Path (SSSP) is one of the widely occurring graph problems where the paths are discovered from an origin vertex to all other vertices in the graph. In this paper, we discuss our experience parallelizing SSSP using OpenSHMEM. We start with the serial Dijkstra and Bellman-Ford algorithms, parallelize these algorithms, and adapt them to the Partitioned Global Address Space (PGAS) programming model. We implement the parallel algorithms using OpenSHMEM and introduce a series of optimizations to achieve higher scaling and performance characteristics. The implementation is evaluated on Titan with various graphs including synthetic Recursive Matrix (R-MAT) and small-world network graphs as well as real-world graphs from Facebook, Twitter, LiveJournal, and the road maps of California and Texas.", "date": "2017-08-07"}, {"link": "https://pdfs.semanticscholar.org/08ae/139d6890717bea0e6243549d66caf24fa78e.pdf", "title": "Teaching Embedded Systems in a MOOC Format", "authors": [{"firstName": "J.", "middleNames": [], "lastName": "Valvano"}, {"firstName": "R.", "middleNames": [], "lastName": "Yerraballi"}, {"firstName": "Chad", "middleNames": [], "lastName": "Fulton"}], "abstract": "We have designed and implemented a Massive Open Online Class (MOOC) with a substantial lab component within the edX platform. We deployed this MOOC three times with a total enrollment of over 100,000 students. If MOOCs are truly going to transform engineering education, then they must be able to deliver classes with laboratory components. Our offering goes a long way in unraveling the perceived complexities in delivering a laboratory experience to thousands of students from around the globe. We believe the techniques developed in this class will significantly transform the MOOC environment. Effective education requires students to learn by doing. In the traditional academic setting this active learning is achieved through a lab component. Translating this to the online environment is a non-trivial task that required several important factors to come together. First, we have significant support from industrial partners ARM Inc. [1] and Texas Instruments [2]. Second, the massive growth of embedded microcontrollers has made the availability of lost-cost development platforms feasible. Third, we have assembled a team with the passion, patience, and experience of delivering quality lab experiences to large classes. Fourth, online tools now exist that allow students to interact and support each other. We used edX for the delivery of videos, interactive animations, text, and quizzes [3]. We used Piazza [4] for discussion boards and Zyante [5] for a programming reference. We partnered with element-14 [6], Digi-Key [7], and Mouser [8] to make the lab kit available and low-cost. Even though there was a $40-$70 cost to purchase the lab kit, the course completion numbers were slightly better than a typical MOOC. 7.3% of the students completed enough of the class to receive a certificate. Students completing end of the course surveys report a 95% overall satisfaction. Demographics show a world-wide reach with India, US, and Egypt being the countries with the most students. In this paper we will present best practices, successes and limitations of teaching a substantial lab across the globe. Background An embedded system combines mechanical, electrical, and chemical components along with a computer, hidden inside, to serve a single dedicated purpose [9-11]. There are over 50 billion processors based on the ARM architecture delivered into products, and most of these computers are single-chip microcontrollers that are the brains of an embedded system. Embedded systems are a ubiquitous component of our everyday lives. We interact with hundreds of tiny computers every day that are embedded into our houses, our cars, our bridges, our toys, and our work. As our world has become more complex, so have the capabilities of the microcontrollers embedded into our devices. Therefore the world needs a trained workforce to develop and manage products based on embedded microcontrollers. Review Other online classes have delivered laboratory experiences. Hesselink at Stanford University developed iLabs as a means to deliver science experiments to online learning. Their lab-in-a-box involves simulations and animations [12]. O\u2019Malley et al. from the University of Manchester developed a Chemistry MOOC with a lab component using virtual labs and simulations [13-14]. University of Washington presented a hardware/software MOOC on Coursera [15]. This course is primarily a programming class without graded physical labs. Ferri et al. from Georgia Institute of Technology created a MOOC for linear circuits [16]. This class had activities to perform with NI\u2019s myDAC, but graded lab circuits were not part of the online experience. Connor, and Huettel at Duke created a Virtual Community of Practice for electric circuits [17]. Cherner et al. created a virtual multifunctional X-Ray diffractometer for teaching science and engineering [18]. Saterbak et al. at Rice University developed online materials to teach freshman design, with the goal to free-up class time for more interactive learning experiences [19]. Harris from University of California at Irvine has a six-course sequence on Introduction to the Internet of Things and Embedded Systems where students build actual embedded devices [20]. Grading for this course uses peer assessment. Lee et al. at Berkeley developed an introduction to embedded systems MOOC with laboratory exercises. The lab itself was a robotic controller in a virtual laboratory environment. Completion of the labs themselves does have an automatic grading component based on the student\u2019s written software [21-22]. All this work emphasizes the need for hands on learning. Pedagogy The overall educational objective of this class is to allow students to discover how computers interact with the environment. The class provides hands-on experiences of how an embedded system could be used to solve problems. The focus of this introductory course is understanding and analysis rather than design, where students learn new techniques by doing them. We feel we have solved the dilemma in learning a laboratory-based topic like embedded systems, where there is a tremendous volume of details that first must be learned before hardware and software systems can be designed. The approach taken in this course is to learn by doing in a bottom-up fashion. One of the advantages of a bottom-up approach to learning is that the student begins by mastering simple concepts. Once the student truly understands simple concepts, he or she can embark on the creative process of design, which involves putting the pieces together to create a more complex system. True creativity involves solving complex problems using effective combinations of simple components. Embedded systems afford an effective platform to teach new engineers how to program for three reasons. First, there is no operating system. Thus, in a bottom-up fashion the student can see, write, and understand all software running on a system that actually does something. Second, embedded systems involve real input/output that is easy for the student to touch, hear, and see. Many engineering students struggle with abstraction. We believe many students learn effectively by using their sense of touch, hearing and sight to first understand and internalize difficult concepts, and then they will be able to develop and appreciate abstractions. Third, embedded systems are employed in many everyday products, motivating students to see firsthand, how engineering processes can be applied in the real world. This course is intended for beginning college students with some knowledge of electricity as would have been taught in an introductory college physics class. Secondly, it is expected students will have some basic knowledge of programming and logic design. No specific language will be assumed as prior knowledge but this class could be taken as their second programming class. We hoped experienced engineers could also use this course to train or retrain in the field of embedded systems. Learning objectives of the course Although the students are engaged with a fun and rewarding lab experience, our educational pedagogy is centered on fundamental learning objectives. After the successful conclusion of this class, students should be able to understand the basic components of a computer, write C language programs that perform input/output interfacing, implement simple data structures, manipulate numbers in multiple formats, and understand how software uses global memory to store permanent information and the stack to store temporary information. Our goal is for students to learn these concepts: 0) How the computer stores and manipulates data; 1) Embedded systems using modular design and abstraction; 2) Design tools like requirements documents, data flow graphs, and call graphs; 3) C programming: considering both function and style; 4) Debugging and verification using a simulator and the real microcontroller; 5) Debugging tools like voltmeters, oscilloscopes, and logic analyzers; 6) How to input/output using switches, LEDs, DACs, ADCs, and serial ports; 7) Implementation of an I/O driver, multithreaded programming, and interrupts; 8) Analog to digital conversion (ADC), periodic sampling, and the Nyquist Theorem; 9) Stepper motors, brushed DC motors, and simple digital controllers; 10) Digital to analog conversion (DAC), used to make simple sounds; 11) Simple distributed systems that connect two microcontrollers; 12) Internet of things, connecting the embedded system to the internet; 13) System-level design that combine multiple components together. Laboratory Kit Active learning requires a platform for the student to learn by doing. Figure 1 shows the components of the basic lab kit. There are two difficulties with a physical lab kit deployed in a world-wide open classroom environment. The first problem is availability of components. We partnered with companies and distributors six months in advance of the course launch to guarantee availability. The companies wanted us to specify the number of students who would buy the kit. In this regard, we were very lucky. Six months prior to our first launch, we estimated 2000 people would register for the class and 1000 would buy the kit. In turns out Texas Instruments produced 10,000 microcontroller boards just in case. Much to our surprise 40,000 people registered and we estimate 11,000 purchased the kit during this first delivery of the course. The second solution to the problem of availability was to have three world-wide distributors (element-14, Mouser, and Digi-Key). Working with these distributors, we created one-click landing pages for students to buy the kit. Furthermore, for each component in the kit (other than the microcontroller board), we had three or more possible parts. The third solution was to design the course with flexible deadlines and pathways. Each lab had a simulation and a real-board requirement. Students who were waiting for the parts to be shipped could proceed with ", "date": "2016-06-26"}, {"link": "http://dl.acm.org/citation.cfm?id=167278", "title": "Matchings in lattice graphs", "authors": [{"firstName": "C.", "middleNames": [], "lastName": "Mathieu"}, {"firstName": "D.", "middleNames": [], "lastName": "Randall"}, {"firstName": "A.", "middleNames": [], "lastName": "Sinclair"}], "abstract": "We study the problem of counting the number of matchings of given cardinalitg in a d-dimensional rectangular lattice. This problem arises in several models in statistical phgsics, including monomerdimer systems and cell-cluster theory. A classical algorithm due to Fisher, Kasteleyn and Temperley counts perfect matchings exactly in two dimensions, but is not applicable in higher dimensions and does not allow one to count matchings of arbitrary cardinality. In this paper, we present the first eficient approximation algorithms for counting matchings of arbitrary cardinality in (i) d-dimensional \u2018>en\u201dodic\u201d lattices (i. e., with wrap-around edges) in any fixed dimension d; and (ii) two-dimensional lattices with \u201cfixed boundary conditions\u201d (i. e., no wrap-around edges). Our technique generalizes to approximately counting matchings in any bipartite graph that is the Cayley graph of some finite group. t CNRS, Ecole Normale Sup&ieure de Lyon, France. Part of this work was done while this author was visiting ICSI, Berkeley. E-mail: kenyon@lip. ens-lyon. f r, $Department of Computer Science, University of California at Berkeley. Supported in part by an AT&T PhD Fellowship and NSF grant CCR88-13632. E-mail: randall@cs. berkeley. edu. $University of Edinburgh and International Computer Science Institute, Berkeley. Supported in part by grant GR/F 90363 of the UK Science and Engineering Research Council. E-mail: sinclairOicsi. berkeley. edu. Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed fc,r \u201cdirect commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of tha Association for Computing Machinery. To copy otherwise, or to rapublish, requires a fea and/or specific permission. 25th ACM STOC \u201893-51931CA,WA 01993 ACM 0-89791 -591 -71931000510738 . ..$1 .50 1 Summary 1.1 Background and mot ivation This paper is concerned with the following computational problem: given a finite lattice graph in some fixed number of dimensions, and some number of dominoes, determine the number of ways of placing dominoes on the edges of the graph so that no two dominoes overlap at a vertex. Equivalently, we can think of dominoes as covering a pair of adjacent squares (cubes) in the dual lattice. This is a classical problem in statistical physics, first introduced by Fowler and Rushbrooke in 1937 [3], and is the earliest example of a large class of problems concerned with computing the number of nonoverlapping arrangements of figures of various shapes on a lattice (see, e.g., [11, 16] for a survey). The problem arises in several physical models. For example, in two dimensions the lattice represents the surface of a crystal and the dominoes diatomic molecules (or dimers), and the number of domino arrangements is the number of ways in which a given number of dimers can attach themselves onto the surface; from this information, most of the thermodynamical properties of the system can be computed. In three dimensions, the same problem occurs in the theory of mixtures of molecules of different sizes and in the cell-cluster theory of the liquid state. For further background information, see [4, 11] and the references given there. The problem also has inherent combinatorial interest: clearly a domino arrangement is simply a mat thing, so we are actually being asked for the number of matchings of specified cardinality in the lattice graph. Counting matchings is a central problem in computer science and has received much attention since the seminal work of Valiant [15], who proved that it is #P-complete for general graphs. The enumeration of perfect matchings (where the dominoes are required to completely cover the graph) is equivalent to computing the permanent of a O-1 matrix, a long-studied problem in its own right [12]. This paper investigates", "date": "1993-06-01"}]